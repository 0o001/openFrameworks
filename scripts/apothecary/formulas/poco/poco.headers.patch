diff -rupN ../Poco-o/AbstractDelegate.h ./AbstractDelegate.h
--- ../Poco-o/AbstractDelegate.h	2013-09-23 14:46:58.000000000 +0100
+++ ./AbstractDelegate.h	2013-09-23 14:57:00.000000000 +0100
@@ -85,6 +85,45 @@ public:
 	}
 };
 
+template <> 
+class AbstractDelegate<void>
+	/// Base class for Delegate and Expire.
+{
+public:
+	AbstractDelegate()
+	{
+	}
+
+	AbstractDelegate(const AbstractDelegate& del)
+	{
+	}
+
+	virtual ~AbstractDelegate() 
+	{
+	}
+
+	virtual bool notify(const void* sender) = 0;
+		/// Invokes the delegate's callback function.
+		/// Returns true if successful, or false if the delegate
+		/// has been disabled or has expired.
+
+	virtual bool equals(const AbstractDelegate& other) const = 0;
+		/// Compares the AbstractDelegate with the other one for equality.
+
+	virtual AbstractDelegate* clone() const = 0;
+		/// Returns a deep copy of the AbstractDelegate.
+
+	virtual void disable() = 0;
+		/// Disables the delegate, which is done prior to removal.
+		
+	virtual const AbstractDelegate* unwrap() const
+		/// Returns the unwrapped delegate. Must be overridden by decorators
+		/// like Expire.
+	{
+		return this;
+	}
+};
+
 
 } // namespace Poco
 
diff -rupN ../Poco-o/AbstractEvent.h ./AbstractEvent.h
--- ../Poco-o/AbstractEvent.h	2013-09-23 14:46:58.000000000 +0100
+++ ./AbstractEvent.h	2013-09-23 15:02:11.000000000 +0100
@@ -171,9 +171,7 @@ class AbstractEvent
 	/// to create the PriorityDelegate.
 {
 public:
-	typedef TArgs Args;
-
-	AbstractEvent(): 
+	AbstractEvent():
 		_executeAsync(this, &AbstractEvent::executeAsyncImpl),
 		_enabled(true)
 	{
@@ -346,6 +344,296 @@ private:
 	AbstractEvent& operator = (const AbstractEvent& other);
 };
 
+template <class TStrategy, class TDelegate, class TMutex> 
+class AbstractEvent<void,TStrategy,TDelegate,TMutex>
+	/// An AbstractEvent is the base class of all events. 
+	/// It works similar to the way C# handles notifications (aka events in C#).
+	///
+	/// Events can be used to send information to a set of delegates
+	/// which are registered with the event. The type of the data is specified with
+	/// the template parameter TArgs. The TStrategy parameter must be a subclass 
+	/// of NotificationStrategy. The parameter TDelegate can either be a subclass of AbstractDelegate
+	/// or of AbstractPriorityDelegate. 
+	///
+	/// Note that AbstractEvent should never be used directly. One ought to use
+	/// one of its subclasses which set the TStrategy and TDelegate template parameters
+	/// to fixed values. For most use-cases the BasicEvent template will be sufficient:
+	///
+	///     #include "Poco/BasicEvent.h"
+	///     #include "Poco/Delegate.h"
+	///
+	/// Note that as of release 1.4.2, the behavior of BasicEvent equals that of FIFOEvent,
+	/// so the FIFOEvent class is no longer necessary and provided for backwards compatibility
+	/// only.
+	///
+	/// BasicEvent works with a standard delegate. They allow one object to register
+	/// onr or more delegates with an event. In contrast, a PriorityDelegate comes with an attached priority value
+	/// and allows one object to register for one priority value one or more delegates. Note that PriorityDelegates
+	/// only work with PriorityEvents:
+	///
+	///     #include "Poco/PriorityEvent.h"
+	///     #include "Poco/PriorityDelegate.h"
+	///
+	/// Use events by adding them as public members to the object which is throwing notifications:
+	///
+	///     class MyData
+	///     {
+	///     public:
+	///         Poco::BasicEvent<int> dataChanged;
+	///         
+	///         MyData();
+	///         ...
+	///         void setData(int i);
+	///         ...
+	///     private:
+	///         int _data;
+	///     };
+	///
+	/// Firing the event is done either by calling the event's notify() or notifyAsync() method:
+	///
+	///     void MyData::setData(int i)
+	///     {
+	///         this->_data = i;
+	///         dataChanged.notify(this, this->_data);
+	///     }
+	///
+	/// Alternatively, instead of notify(), operator () can be used.
+	///
+	///     void MyData::setData(int i)
+	///     {
+	///         this->_data = i;
+	///         dataChanged(this, this->_data);
+	///     }
+	///
+	/// Note that operator (), notify() and notifyAsync() do not catch exceptions, i.e. in case a  
+	/// delegate throws an exception, notifying is immediately aborted and the exception is propagated
+	/// back to the caller.
+	///
+	/// Delegates can register methods at the event. In the case of a BasicEvent
+	/// the Delegate template is used, in case of an PriorityEvent a PriorityDelegate is used.
+	/// Mixing of delegates, e.g. using a PriorityDelegate with a BasicEvent is not allowed and
+	/// can lead to compile-time and/or run-time errors. The standalone delegate() functions
+	/// can be used to construct Delegate objects.
+	///
+	/// Events require the observers to have one of the following method signatures:
+	///
+	///     void onEvent(const void* pSender, TArgs& args);
+	///     void onEvent(TArgs& args);
+	///     static void onEvent(const void* pSender, TArgs& args);
+	///     static void onEvent(void* pSender, TArgs& args);
+	///     static void onEvent(TArgs& args);
+	///
+	/// For performance reasons arguments are always sent by reference. This also allows observers
+	/// to modify the event argument. To prevent that, use <[const TArg]> as template
+	/// parameter. A non-conformant method signature leads to compile errors.
+	///
+	/// Assuming that the observer meets the method signature requirement, it can register
+	/// this method with the += operator:
+	///
+	///     class MyController
+	///     {
+	///     protected:
+	///         MyData _data;
+	///         
+	///         void onDataChanged(void* pSender, int& data);
+	///         ...
+	///     };
+	///         
+	///     MyController::MyController()
+	///     {
+	///         _data.dataChanged += delegate(this, &MyController::onDataChanged);
+	///     }
+	///
+	/// In some cases it might be desirable to work with automatically expiring registrations. Simply add
+	/// to delegate as 3rd parameter a expireValue (in milliseconds):
+	///
+	///     _data.dataChanged += delegate(this, &MyController::onDataChanged, 1000);
+	///
+	/// This will add a delegate to the event which will automatically be removed in 1000 millisecs.
+	///
+	/// Unregistering happens via the -= operator. Forgetting to unregister a method will lead to
+	/// segmentation faults later, when one tries to send a notify to a no longer existing object.
+	///
+	///     MyController::~MyController()
+	///     {
+	///         _data.dataChanged -= delegate(this, &MyController::onDataChanged);
+	///     }
+	///
+	/// Working with PriorityDelegate's as similar to working with BasicEvent.
+	/// Instead of delegate(), the priorityDelegate() function must be used
+	/// to create the PriorityDelegate.
+{
+public:
+	AbstractEvent(): 
+		_executeAsync(this, &AbstractEvent::executeAsyncImpl),
+		_enabled(true)
+	{
+	}
+
+	AbstractEvent(const TStrategy& strat): 
+		_executeAsync(this, &AbstractEvent::executeAsyncImpl),
+		_strategy(strat),
+		_enabled(true)
+	{	
+	}
+
+	virtual ~AbstractEvent()
+	{
+	}
+
+	void operator += (const TDelegate& aDelegate)
+		/// Adds a delegate to the event. 
+		///
+		/// Exact behavior is determined by the TStrategy.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		_strategy.add(aDelegate);
+	}
+	
+	void operator -= (const TDelegate& aDelegate)
+		/// Removes a delegate from the event.
+		///
+		/// If the delegate is not found, this function does nothing.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		_strategy.remove(aDelegate);
+	}
+	
+	void operator () (const void* pSender)
+		/// Shortcut for notify(pSender, args);
+	{
+		notify(pSender);
+	}
+	
+	void operator () ()
+		/// Shortcut for notify(args).
+	{
+		notify(0);
+	}
+
+	void notify(const void* pSender)
+		/// Sends a notification to all registered delegates. The order is 
+		/// determined by the TStrategy. This method is blocking. While executing,
+		/// the list of delegates may be modified. These changes don't
+		/// influence the current active notifications but are activated with
+		/// the next notify. If a delegate is removed during a notify(), the
+		/// delegate will no longer be invoked (unless it has already been
+		/// invoked prior to removal). If one of the delegates throws an exception, 
+		/// the notify method is immediately aborted and the exception is propagated
+		/// to the caller.
+	{
+		Poco::ScopedLockWithUnlock<TMutex> lock(_mutex);
+		
+		if (!_enabled) return;
+		
+		// thread-safeness: 
+		// copy should be faster and safer than blocking until
+		// execution ends
+		TStrategy strategy(_strategy);
+		lock.unlock();
+		strategy.notify(pSender);
+	}
+
+	ActiveResult<void> notifyAsync(const void* pSender)
+		/// Sends a notification to all registered delegates. The order is 
+		/// determined by the TStrategy. This method is not blocking and will
+		/// immediately return. The delegates are invoked in a seperate thread.
+		/// Call activeResult.wait() to wait until the notification has ended.
+		/// While executing, other objects can change the delegate list. These changes don't
+		/// influence the current active notifications but are activated with
+		/// the next notify. If a delegate is removed during a notify(), the
+		/// delegate will no longer be invoked (unless it has already been
+		/// invoked prior to removal). If one of the delegates throws an exception, 
+		/// the execution is aborted and the exception is propagated to the caller.
+	{
+		NotifyAsyncParams params(pSender);
+		{
+			typename TMutex::ScopedLock lock(_mutex);
+
+			// thread-safeness: 
+			// copy should be faster and safer than blocking until
+			// execution ends
+			// make a copy of the strategy here to guarantee that
+			// between notifyAsync and the execution of the method no changes can occur
+				
+			params.ptrStrat = SharedPtr<TStrategy>(new TStrategy(_strategy));
+			params.enabled  = _enabled;
+		}
+		ActiveResult<void> result = _executeAsync(params);
+		return result;
+	}
+	
+	void enable()
+		/// Enables the event.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		_enabled = true;
+	}
+
+	void disable()
+		/// Disables the event. notify and notifyAsnyc will be ignored,
+		/// but adding/removing delegates is still allowed.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		_enabled = false;
+	}
+
+	bool isEnabled() const
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		return _enabled;
+	}
+
+	void clear()
+		/// Removes all delegates.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		_strategy.clear();
+	}
+	
+	bool empty() const
+		/// Checks if any delegates are registered at the delegate.
+	{
+		typename TMutex::ScopedLock lock(_mutex);
+		return _strategy.empty();
+	}
+
+protected:
+	struct NotifyAsyncParams
+	{
+		SharedPtr<TStrategy> ptrStrat;
+		const void* pSender;
+		bool        enabled;
+		
+		NotifyAsyncParams(const void* pSend):ptrStrat(), pSender(pSend), enabled(true)
+			/// Default constructor reduces the need for TArgs to have an empty constructor, only copy constructor is needed.
+		{
+		}
+	};
+
+	ActiveMethod<void, NotifyAsyncParams, AbstractEvent> _executeAsync;
+
+	void executeAsyncImpl(const NotifyAsyncParams& par)
+	{
+		if (!par.enabled)
+		{
+			return;
+		}
+
+		NotifyAsyncParams params = par;
+		params.ptrStrat->notify(params.pSender);
+		return;
+	}
+
+	TStrategy _strategy; /// The strategy used to notify observers.
+	bool      _enabled;  /// Stores if an event is enabled. Notfies on disabled events have no effect
+	                     /// but it is possible to change the observers.
+	mutable TMutex _mutex;
+
+private:
+	AbstractEvent(const AbstractEvent& other);
+	AbstractEvent& operator = (const AbstractEvent& other);
+};
 
 } // namespace Poco
 
diff -rupN ../Poco-o/Net/X509Certificate.h ./Net/X509Certificate.h
--- ../Poco-o/Net/X509Certificate.h	2013-09-23 14:46:58.000000000 +0100
+++ ./Net/X509Certificate.h	2013-09-23 15:03:15.000000000 +0100
@@ -47,6 +47,9 @@
 #include "Poco/SharedPtr.h"
 #include <set>
 
+#ifdef verify 
+#undef verify 
+#endif
 
 namespace Poco {
 namespace Net {
diff -rupN ../Poco-o/NotificationStrategy.h ./NotificationStrategy.h
--- ../Poco-o/NotificationStrategy.h	2013-09-23 14:46:58.000000000 +0100
+++ ./NotificationStrategy.h	2013-09-23 15:02:58.000000000 +0100
@@ -80,6 +80,40 @@ public:
 		/// Returns false if the strategy contains at least one delegate.
 };
 
+template <class TDelegate> 
+class NotificationStrategy<void,TDelegate>
+	/// The interface that all notification strategies must implement.
+	/// 
+	/// Note: Event is based on policy-driven design, so every strategy implementation
+	/// must provide all the methods from this interface (otherwise: compile errors)
+	/// but does not need to inherit from NotificationStrategy.
+{
+public:
+	NotificationStrategy()
+	{
+	}
+
+	virtual ~NotificationStrategy()
+	{
+	}
+
+	virtual void notify(const void* sender) = 0;
+		/// Sends a notification to all registered delegates.
+
+	virtual void add(const TDelegate& delegate) = 0;
+		/// Adds a delegate to the strategy.
+
+	virtual void remove(const TDelegate& delegate) = 0;
+		/// Removes a delegate from the strategy, if found.
+		/// Does nothing if the delegate has not been added.
+
+	virtual void clear() = 0;
+		/// Removes all delegates from the strategy.
+
+	virtual bool empty() const = 0;
+		/// Returns false if the strategy contains at least one delegate.
+};
+
 
 } // namespace Poco
 
diff -rupN ../Poco-o/PriorityStrategy.h ./PriorityStrategy.h
--- ../Poco-o/PriorityStrategy.h	2013-09-23 14:46:58.000000000 +0100
+++ ./PriorityStrategy.h	2013-09-23 15:02:58.000000000 +0100
@@ -135,7 +135,80 @@ protected:
 	Delegates _delegates;
 };
 
+template <class TDelegate>
+class PriorityStrategy<void, TDelegate>
+	/// NotificationStrategy for PriorityEvent.
+	///
+	/// Delegates are kept in a std::vector<>, ordered
+	/// by their priority.
+{
+public:
+	typedef SharedPtr<TDelegate>         DelegatePtr;
+	typedef std::vector<DelegatePtr>     Delegates;
+	typedef typename Delegates::iterator Iterator;
 
+public:
+
+	void notify(const void* sender)
+	{
+		for (Iterator it = _delegates.begin(); it != _delegates.end(); ++it)
+		{
+			(*it)->notify(sender);
+		}
+	}
+
+	void add(const TDelegate& delegate)
+	{
+		for (Iterator it = _delegates.begin(); it != _delegates.end(); ++it)
+		{
+			if ((*it)->priority() > delegate.priority())
+			{
+				_delegates.insert(it, DelegatePtr(static_cast<TDelegate*>(delegate.clone())));
+				return;
+			}
+		}
+		_delegates.push_back(DelegatePtr(static_cast<TDelegate*>(delegate.clone())));
+	}
+
+	void remove(const TDelegate& delegate)
+	{
+		for (Iterator it = _delegates.begin(); it != _delegates.end(); ++it)
+		{
+			if (delegate.equals(**it))
+			{
+				(*it)->disable();
+				_delegates.erase(it);
+				return;
+			}
+		}
+	}
+
+	PriorityStrategy& operator = (const PriorityStrategy& s)
+	{
+		if (this != &s)
+		{
+			_delegates = s._delegates;
+		}
+		return *this;
+	}
+
+	void clear()
+	{
+		for (Iterator it = _delegates.begin(); it != _delegates.end(); ++it)
+		{
+			(*it)->disable();
+		}
+		_delegates.clear();
+	}
+
+	bool empty() const
+	{
+		return _delegates.empty();
+	}
+
+protected:
+	Delegates _delegates;
+};
 } // namespace Poco
 
 
